Index: lib/libpam/modules/pam_unix/pam_unix.c
===================================================================
--- lib/libpam/modules/pam_unix/pam_unix.c	(revision 311944)
+++ lib/libpam/modules/pam_unix/pam_unix.c	(working copy)
@@ -396,8 +396,12 @@
 		switch (old_pwd->pw_fields & _PWF_SOURCE) {
 		case _PWF_FILES:
 #endif
+		{
+			const void *passwd_tmp_dir = NULL;
+
 			retval = PAM_SERVICE_ERR;
-			if (pw_init(NULL, NULL))
+			(void)pam_get_data(pamh, "passwd_tmp_dir", &passwd_tmp_dir);
+			if (pw_init((const char *) passwd_tmp_dir, NULL))
 				openpam_log(PAM_LOG_ERROR, "pw_init() failed");
 			else if ((pfd = pw_lock()) == -1)
 				openpam_log(PAM_LOG_ERROR, "pw_lock() failed");
@@ -410,6 +414,7 @@
 			else
 				retval = PAM_SUCCESS;
 			pw_fini();
+		}
 #ifdef YP
 			break;
 		case _PWF_NIS:
Index: lib/libutil/_secure_path.c
===================================================================
--- lib/libutil/_secure_path.c	(revision 311944)
+++ lib/libutil/_secure_path.c	(working copy)
@@ -23,6 +23,7 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <sys/sysctl.h>
 #include <sys/stat.h>
 
 #include <errno.h>
@@ -30,6 +31,8 @@
 #include <stddef.h>
 #include <syslog.h>
 
+static int (*statcalls[])(const char * restrict, struct stat * restrict) = { lstat, stat };
+
 /*
  * Check for common security problems on a given path
  * It must be:
@@ -46,10 +49,12 @@
 _secure_path(const char *path, uid_t uid, gid_t gid)
 {
     int		r = -1;
+    int jailed = 0;
     struct stat	sb;
     const char	*msg = NULL;
+    size_t jailed_len = sizeof(jailed);
 
-    if (lstat(path, &sb) < 0) {
+    if (statcalls[0 == sysctlbyname("security.jail.jailed", &jailed, &jailed_len, NULL, 0) && jailed](path, &sb) < 0) {
 	if (errno == ENOENT) /* special case */
 	    r = -2;  /* if it is just missing, skip the log entry */
 	else
Index: lib/libutil/gr_util.c
===================================================================
--- lib/libutil/gr_util.c	(revision 311944)
+++ lib/libutil/gr_util.c	(working copy)
@@ -43,6 +43,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
 
 static int lockfd = -1;
 static char group_dir[PATH_MAX];
@@ -60,7 +62,17 @@
 {
 
 	if (dir == NULL) {
-		strcpy(group_dir, _PATH_ETC);
+		int jailed;
+		size_t jailed_len;
+
+		jailed = 0;
+		jailed_len = sizeof(jailed);
+		if (0 == sysctlbyname("security.jail.jailed", &jailed, &jailed_len, NULL, 0) && jailed) {
+			strcpy(group_dir, "/private/etc");
+		} else {
+			strcpy(group_dir, _PATH_ETC);
+		}
+		dir = group_dir;
 	} else {
 		if (strlen(dir) >= sizeof(group_dir)) {
 			errno = ENAMETOOLONG;
Index: lib/libutil/pw_util.c
===================================================================
--- lib/libutil/pw_util.c	(revision 311944)
+++ lib/libutil/pw_util.c	(working copy)
@@ -65,6 +65,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
 
 #include "libutil.h"
 
@@ -97,7 +99,17 @@
 #endif
 
 	if (dir == NULL) {
-		strcpy(passwd_dir, _PATH_ETC);
+		int jailed;
+		size_t jailed_len;
+
+		jailed = 0;
+		jailed_len = sizeof(jailed_len);
+		if (0 == sysctlbyname("security.jail.jailed", &jailed, &jailed_len, NULL, 0) && jailed) {
+			strcpy(passwd_dir, "/private/etc");
+		} else {
+			strcpy(passwd_dir, _PATH_ETC);
+		}
+		dir = passwd_dir;
 	} else {
 		if (strlen(dir) >= sizeof(passwd_dir)) {
 			errno = ENAMETOOLONG;
Index: usr.bin/chpass/chpass.1
===================================================================
--- usr.bin/chpass/chpass.1	(revision 311944)
+++ usr.bin/chpass/chpass.1	(working copy)
@@ -45,6 +45,7 @@
 .Op Fl p Ar encpass
 .Op Fl e Ar expiretime
 .Op Fl s Ar newshell
+.Op Fl t Ar directory
 .Op user
 .Nm
 .Op Fl oly
@@ -52,6 +53,7 @@
 .Op Fl p Ar encpass
 .Op Fl e Ar expiretime
 .Op Fl s Ar newshell
+.Op Fl t Ar directory
 .Op Fl d Ar domain
 .Op Fl h Ar host
 .Op user
@@ -102,6 +104,11 @@
 .It Fl s Ar newshell
 Attempt to change the user's shell to
 .Ar newshell .
+.It Fl t Ar directory
+Use an alternate
+.Ar directory
+to look for the password files than the default
+.It /etc .
 .El
 .Pp
 Possible display items are as follows:
Index: usr.bin/chpass/chpass.c
===================================================================
--- usr.bin/chpass/chpass.c	(revision 311944)
+++ usr.bin/chpass/chpass.c	(working copy)
@@ -82,6 +82,7 @@
 	struct passwd lpw, *old_pw, *pw;
 	int ch, pfd, tfd;
 	const char *password;
+	const char *passwd_tmp_dir = NULL;
 	char *arg = NULL;
 	uid_t uid;
 #ifdef YP
@@ -92,9 +93,9 @@
 	pw = old_pw = NULL;
 	op = EDITENTRY;
 #ifdef YP
-	while ((ch = getopt(argc, argv, "a:p:s:e:d:h:loy")) != -1)
+	while ((ch = getopt(argc, argv, "a:p:s:e:d:h:t:loy")) != -1)
 #else
-	while ((ch = getopt(argc, argv, "a:p:s:e:")) != -1)
+	while ((ch = getopt(argc, argv, "a:p:s:e:t:")) != -1)
 #endif
 		switch (ch) {
 		case 'a':
@@ -126,6 +127,9 @@
 			/* compatibility */
 			break;
 #endif
+		case 't':
+			passwd_tmp_dir = optarg;
+			break;
 		case '?':
 		default:
 			usage();
@@ -206,7 +210,7 @@
 		 * We don't really need pw_*() here, but pw_edit() (used
 		 * by edit()) is just too useful...
 		 */
-		if (pw_init(NULL, NULL))
+		if (pw_init(passwd_tmp_dir, NULL))
 			err(1, "pw_init()");
 		if ((tfd = pw_tmp(-1)) == -1) {
 			pw_fini();
@@ -256,7 +260,7 @@
 #endif /* YP */
 	case 0:
 	case _PWF_FILES:
-		if (pw_init(NULL, NULL))
+		if (pw_init(passwd_tmp_dir, NULL))
 			err(1, "pw_init()");
 		if ((pfd = pw_lock()) == -1) {
 			pw_fini();
Index: usr.bin/passwd/passwd.1
===================================================================
--- usr.bin/passwd/passwd.1	(revision 311944)
+++ usr.bin/passwd/passwd.1	(working copy)
@@ -37,6 +37,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl l
+.Op Fl t Ar directory
 .Op Ar user
 .Nm yppasswd
 .Op Fl l
@@ -76,6 +77,11 @@
 When changing only the local password,
 .Xr pwd_mkdb 8
 is used to update the password databases.
+.It Fl t Ar directory
+specify an alternative
+.Fa directory
+for the password file
+.Pa master.passwd
 .El
 .Pp
 When changing local or NIS password, the next password change date
Index: usr.bin/passwd/passwd.c
===================================================================
--- usr.bin/passwd/passwd.c	(revision 311944)
+++ usr.bin/passwd/passwd.c	(working copy)
@@ -55,11 +55,12 @@
 
 static char	*yp_domain;
 static char	*yp_host;
+static char	*passwd_tmp_dir;
 
 static void
 usage(void)
 {
-	fprintf(stderr, "usage: passwd [-ly] [-d domain] [-h host] [user]\n");
+	fprintf(stderr, "usage: passwd [-ly] [-d domain] [-h host] [-t directory] [user]\n");
 	exit(1);
 }
 
@@ -71,7 +72,7 @@
 	int o, pam_err;
 	uid_t uid;
 
-	while ((o = getopt(argc, argv, "d:h:loy")) != -1)
+	while ((o = getopt(argc, argv, "d:h:t:loy")) != -1)
 		switch (o) {
 		case 'd':
 			yp_domain = optarg;
@@ -79,6 +80,9 @@
 		case 'h':
 			yp_host = optarg;
 			break;
+		case 't':
+			passwd_tmp_dir = optarg;
+			break;
 		case 'l':
 		case 'o':
 		case 'y':
@@ -154,6 +158,12 @@
 	pam_err = pam_set_data(pamh, "yp_server", yp_host, NULL);
 	pam_check("pam_set_data");
 
+	/* set temporary directory if given */
+	if (passwd_tmp_dir != NULL) {
+		pam_err = pam_set_data(pamh, "passwd_tmp_dir", passwd_tmp_dir, NULL);
+		pam_check("pam_set_data");
+	}
+
 	/* set new password */
 	pam_err = pam_chauthtok(pamh, 0);
 	pam_check("pam_chauthtok");
Index: usr.sbin/jail/config.c
===================================================================
--- usr.sbin/jail/config.c	(revision 311944)
+++ usr.sbin/jail/config.c	(working copy)
@@ -371,8 +371,10 @@
 			free(dp->name);
 			dp->name = estrdup(name);
 		}
-		if (!(flags & PF_APPEND) || TAILQ_EMPTY(&nss))
+		if (!(flags & (PF_APPEND|PF_PREPEND)) || TAILQ_EMPTY(&nss))
 			free_param_strings(dp);
+		if (0 != (flags & PF_PREPEND))
+			TAILQ_SWAP(&dp->val, &nss, cfstring, tq);
 		TAILQ_CONCAT(&dp->val, &nss, tq);
 		dp->flags |= flags;
 	} else {
Index: usr.sbin/jail/jaillex.l
===================================================================
--- usr.sbin/jail/jaillex.l	(revision 311944)
+++ usr.sbin/jail/jaillex.l	(working copy)
@@ -71,9 +71,14 @@
 			}
 
 			/* Reserved tokens */
-<_>\+=			{
+<_>\[=			{
 				instr = 0;
-				return PLEQ;
+				return OP_PREPEND;
+}
+<_>\+= |
+<_>\]=			{
+				instr = 0;
+				return OP_APPEND;
 			}
 <_>[,;={}]		{
 				instr = 0;
Index: usr.sbin/jail/jailp.h
===================================================================
--- usr.sbin/jail/jailp.h	(revision 311944)
+++ usr.sbin/jail/jailp.h	(working copy)
@@ -52,6 +52,7 @@
 #define PF_CONV		0x40	/* Parameter duplicated in converted form */
 #define PF_REV		0x80	/* Run commands in reverse order on stopping */
 #define	PF_IMMUTABLE	0x100	/* Immutable parameter */
+#define PF_PREPEND	0x200	/* Prepend to existing parameter list */
 
 #define JF_START	0x0001	/* -c */
 #define JF_SET		0x0002	/* -m */
Index: usr.sbin/jail/jailparse.y
===================================================================
--- usr.sbin/jail/jailparse.y	(revision 311944)
+++ usr.sbin/jail/jailparse.y	(working copy)
@@ -47,7 +47,8 @@
 	char			*cs;
 }
 
-%token      PLEQ
+%token      OP_APPEND
+%token      OP_PREPEND
 %token <cs> STR STR1 VAR VAR1
 
 %type <j>  jail
@@ -115,7 +116,7 @@
 		TAILQ_CONCAT(&$$->val, $3, tq);
 		free($3);
 	}
-	| name PLEQ value
+	| name OP_APPEND value
 	{
 		$$ = $1;
 		TAILQ_CONCAT(&$$->val, $3, tq);
@@ -122,7 +123,15 @@
 		$$->flags |= PF_APPEND;
 		free($3);
 	}
+	| name OP_PREPEND value
+	{
+		$$ = $1;
+		TAILQ_CONCAT(&$$->val, $3, tq);
+		$$->flags |= PF_PREPEND;
+		free($3);
+	}
 	| name value
+	| name value
 	{
 		$$ = $1;
 		TAILQ_CONCAT(&$$->val, $2, tq);
Index: usr.sbin/pw/grupd.c
===================================================================
--- usr.sbin/pw/grupd.c	(revision 311944)
+++ usr.sbin/pw/grupd.c	(working copy)
@@ -42,7 +42,7 @@
 {
 	static char pathbuf[MAXPATHLEN];
 
-	snprintf(pathbuf, sizeof pathbuf, "%s/%s", conf.etcpath, file);
+	snprintf(pathbuf, sizeof pathbuf, "%s/%s", NULL == conf.etcpath ? _PATH_PWD : conf.etcpath, file);
 
 	return (pathbuf);
 }
Index: usr.sbin/pw/pw.c
===================================================================
--- usr.sbin/pw/pw.c	(revision 311944)
+++ usr.sbin/pw/pw.c	(working copy)
@@ -118,8 +118,8 @@
 	arg1 = NULL;
 	relocated = nis = false;
 	memset(&conf, 0, sizeof(conf));
+	conf.etcpath = NULL;
 	strlcpy(conf.rootdir, "/", sizeof(conf.rootdir));
-	strlcpy(conf.etcpath, _PATH_PWD, sizeof(conf.etcpath));
 	conf.fd = -1;
 	conf.checkduplicate = true;
 
@@ -159,7 +159,7 @@
 					    sizeof(conf.rootdir));
 					PWF._altdir = PWF_ROOTDIR;
 				}
-				snprintf(conf.etcpath, sizeof(conf.etcpath),
+				snprintf(conf.etcpath = conf.etcbuf, sizeof(conf.etcbuf),
 				    "%s%s", optarg, arg == 'R' ? "/etc" : "");
 			} else
 				break;
Index: usr.sbin/pw/pw_utils.c
===================================================================
--- usr.sbin/pw/pw_utils.c	(revision 311944)
+++ usr.sbin/pw/pw_utils.c	(working copy)
@@ -71,7 +71,7 @@
 
 	if (config != NULL)
 		return (read_userconfig(config));
-	snprintf(defaultcfg, sizeof(defaultcfg), "%s/pw.conf", conf.etcpath);
+	snprintf(defaultcfg, sizeof(defaultcfg), "%s/pw.conf", NULL == conf.etcpath ? _PATH_PWD : conf.etcpath);
 	return (read_userconfig(defaultcfg));
 }
 
Index: usr.sbin/pw/pwupd.c
===================================================================
--- usr.sbin/pw/pwupd.c	(revision 311944)
+++ usr.sbin/pw/pwupd.c	(working copy)
@@ -47,7 +47,7 @@
 {
 	static char pathbuf[MAXPATHLEN];
 
-	snprintf(pathbuf, sizeof pathbuf, "%s/%s", conf.etcpath, file);
+	snprintf(pathbuf, sizeof pathbuf, "%s/%s", NULL == conf.etcpath ? _PATH_PWD : conf.etcpath, file);
 
 	return (pathbuf);
 }
@@ -62,7 +62,7 @@
 	args[i++] = _PATH_PWD_MKDB;
 	args[i++] = "-C";
 
-	if (strcmp(conf.etcpath, _PATH_PWD) != 0) {
+	if (NULL != conf.etcpath) {
 		args[i++] = "-d";
 		args[i++] = conf.etcpath;
 	}
Index: usr.sbin/pw/pwupd.h
===================================================================
--- usr.sbin/pw/pwupd.h	(revision 311944)
+++ usr.sbin/pw/pwupd.h	(working copy)
@@ -82,7 +82,8 @@
 
 struct pwconf {
 	char		 rootdir[MAXPATHLEN];
-	char		 etcpath[MAXPATHLEN];
+	char		 *etcpath;
+	char		 etcbuf[MAXPATHLEN];
 	int		 fd;
 	int		 rootfd;
 	bool		 checkduplicate;
